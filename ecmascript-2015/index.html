<!DOCTYPE html>
<html lang="zh-Hans">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Histuki9">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Histuki9">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog,Hitsuki9">
    
    <meta name="description" content="前端萌新">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>《ECMAScript 6 入门》读书笔记 · Hitsuki9&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #808080 0, #808080 80px, #696969 80px, #696969 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon-hitsuki9.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 4.2.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Hitsuki9&#39;s Blog.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">《ECMAScript 6 入门》读书笔记</a>
            </div>
    </div>
    
    <a class="home-link" href=/>Hitsuki9's Blog.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/index.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            《ECMAScript 6 入门》读书笔记
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "前端">前端</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">11.2k</span>阅读时长: <span class="post-count reading-time">44 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/06/27</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>var</code> 命令会发生“变量提升”现象，即变量可以在声明之前使用，值为 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出 undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo; <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出 undefined</span></span><br><span class="line">foo = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><code>let</code> 命令所声明的变量一定要在声明后使用，否则报 <code>ReferenceError</code>错误。</p>
<hr>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在 <code>let</code> 命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<p>在代码块内，使用 <code>let</code> 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="string">'dd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ 开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ 结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>let</code> 命令声明变量 <code>tmp</code> 之前，都属于变量 <code>tmp</code> 的“死区”。</p>
<p>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经<strong>存在</strong>了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<hr>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p><code>let</code> 不允许在相同作用域内，重复声明同一个变量，因此，不能在函数内部重新声明参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func(); <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES5 只有全局作用域和函数作用域，ES6 中引入了块级作用域，块级作用域是由一对 <code>{}</code> 包裹的区域，包括条件语句和循环语句以及 <code>try</code> <code>catch</code> 中的 <code>{}</code> (<strong>不写 <code>{}</code> 则不存在块级作用域</strong>)。</p>
<blockquote>
<p>块级作用域可以防止：</p>
</blockquote>
<ol>
<li>内层变量覆盖外层变量；</li>
<li>局部变量泄露为全局变量。</li>
</ol>
<p>ES6 允许块级作用域的任意嵌套。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<p>ES5 规定，函数只能在全局作用域和函数作用域之中声明，不能在块级作用域声明，ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。<br>ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，在块级作用域之外不可引用。</p>
<blockquote>
<p>ES6 在附录 B 里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
</blockquote>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于 <code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p><strong>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</strong></p>
<p>&nbsp;</p>
<h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><p><code>const</code> 声明一个只读的常量,一旦声明，常量的值就不能改变，且一旦声明，就必须立即初始化，不能留到以后赋值。</p>
<p>其余特性与 <code>let</code> 相同。</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code> 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code> 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<p>如果真的想将对象冻结，应该使用 <code>Object.freeze</code> 方法，且如果对象中的属性有为对象的，应该递归调用 <code>Object.freeze</code> 方法。</p>
<p>&nbsp;</p>
<h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><p>解构赋值属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>如果解构不成功，变量的值就等于 <code>undefined</code>。</p>
<p>如果等号的右边不是可遍历的结构（具备 Iterator 接口），那么将会报错。</p>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x; <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>

<p><strong>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Generator 函数原生具有 Iterator 接口</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>

<p><strong>只有当一个数组成员严格等于(<code>===</code>) <code>undefined</code>，默认值才会生效。</strong></p>
<p>默认值可以是一个表达式，如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  x = [<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = []; <span class="comment">// x = 1; y = 1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>]; <span class="comment">// x = 2; y = 2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x = 1; y = 2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = []; <span class="comment">// ReferenceError: y is not defined</span></span><br><span class="line"><span class="keyword">var</span> [x = y, y = <span class="number">1</span>] = []; <span class="comment">// x = undefined; y = 1</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h2><p>对象的解构与数组有一个重要的不同，数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<p>如果解构失败，变量的值等于 <code>undefined</code>。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz; <span class="comment">// "aaa"</span></span><br></pre></td></tr></table></figure>

<p>这实际上说明，对象的解构赋值是下面形式的简写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是<strong>后者</strong>，而不是前者。</p>
<p>嵌套结构的对象想要同时获得内层与外层的变量值，写法如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  p,</span><br><span class="line">  p: &#123; y &#125;</span><br><span class="line">&#125; = obj;</span><br><span class="line">y; <span class="comment">// "World"</span></span><br><span class="line">p; <span class="comment">// &#123;y: "World"&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<p><strong>对象的解构赋值可以取到继承的属性。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj2;</span><br><span class="line">foo; <span class="comment">// "bar"</span></span><br></pre></td></tr></table></figure>

<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>同数组的解构赋值相同。</p>
<hr>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>

<p>将一个已经声明的变量用于解构赋值，JavaScript 引擎会将 <code>{x}</code> 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123; x &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构，数组的下标对应对象的键名。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="number">0</span>: first, [arr.length - <span class="number">1</span>]: last &#125; = arr;</span><br><span class="line">first; <span class="comment">// 1</span></span><br><span class="line">last; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="字符串的结构赋值"><a href="#字符串的结构赋值" class="headerlink" title="字符串的结构赋值"></a>字符串的结构赋值</h2><p>字符串进行解构赋值时，其被转换成了一个类似数组的对象。</p>
<p>类似数组的对象都有一个 <code>length</code> 属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">length</span>: len &#125; = <span class="string">'hello'</span>;</span><br><span class="line">len; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对应的包装对象。</p>
<p><strong>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 <code>undefined</code> 和 <code>null</code> 无法转为对象，所以对它们进行解构赋值，都会报错。</strong></p>
<p>&nbsp;</p>
<h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y = <span class="number">2</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为解构赋值的变量指定默认值</span></span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x, y &#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为函数的参数指定默认值，传入的参数为 undefined 才会触发函数参数的默认值。</span></span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>可以使用圆括号的情况只有一种：<strong>赋值语句</strong>的<strong>非模式</strong>部分，可以使用圆括号。</p>
<p>&nbsp;</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>交换变量的值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回多个值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数参数的定义</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>遍历 Map 结构</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' is '</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><p>ES6 加强了对 Unicode 的支持，允许采用 <code>\uxxxx</code> 形式表示一个字符，其中 <code>xxxx</code> 表示字符的 Unicode 码点。</p>
<p>这种表示法只限于码点在 <code>\u0000</code> ~ <code>\uFFFF</code> 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<p>对于 <code>\u</code> 后面跟着超过 <code>0xFFFF</code> 的数值的值，ES6 做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\uD842\uDFB7'</span>;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u&#123;20BB7&#125;'</span>;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个码点组成的字符第一个码点要在 <code>0xD800</code> ~ <code>0xDBFF</code> 之间，即前 6 位固定为 <code>1101 10</code>。第二个码点要求在 <code>0xDC00</code> ~ <code>0xDFFF</code> 之间，即前 6 位固定为 <code>1101 11</code> 。这样每个码点可以空出 10 位，两个码点可以表示 2^20 个字符。对于编码小于等于 <code>0xFFFF</code> 的，一个码点即表示一个字符。对于编码大于 <code>0xFFFF</code> 的字符，先减去 <code>0x10000</code> ，然后转换为 20 位的二进制数，然后分别填充两个码点空出的 10 位，这就是需要两个码点字符的保存方式。<br>ES6 新语法规定，对于超出 <code>0xFFFF</code> 的编码可以直接用 <code>{}</code> 写出,如 <code>\u{xxxxx}</code>，对于 <code>\u{1F680}</code>：<br><code>0x1F680</code> - <code>0x10000</code> = <code>0xF680</code> = <code>0000 1111 0110 1000 0000</code><br>第一个码点是 <code>1101 10|00 0011 1101</code> = <code>0xD83D</code><br>第二个码点是 <code>1101 11|10 1000 0000</code> = <code>0xDE80</code>。</p>
</blockquote>
<p>JavaScript 规定有 5 个字符，不能在<strong>字符串</strong>里面直接使用，只能使用转义形式。</p>
<blockquote>
<ul>
<li>U+005C：反斜杠（reverse solidus)</li>
</ul>
</blockquote>
<ul>
<li>U+000D：回车（carriage return）</li>
<li>U+2028：行分隔符（line separator）</li>
<li>U+2029：段分隔符（paragraph separator）</li>
<li>U+000A：换行符（line feed）</li>
</ul>
<p><strong>ES2019 允许 JavaScript 字符串直接输入 U+2028（行分隔符）和 U+2029（段分隔符），模板字符串现在就允许直接输入这两个字符。</strong></p>
<p>&nbsp;</p>
<h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><p>ES6 为字符串添加了遍历器接口，使得字符串可以被 <code>for...of</code> 循环遍历，遍历器可以识别大于 <code>0xFFFF</code> 的码点（传统的 <code>for</code> 循环不行）。</p>
<p>&nbsp;</p>
<h2 id="JSON-stringify-的改造"><a href="#JSON-stringify-的改造" class="headerlink" title="JSON.stringify()的改造"></a>JSON.stringify()的改造</h2><p>为了确保返回的是合法的 UTF-8 字符，ES2019 改变了 <code>JSON.stringify()</code> 的行为，如果遇到 <code>0xD800</code> 到 <code>0xDFFF</code> 之间的单个码点，或者不存在的配对形式，它会返回转义字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="string">'\u&#123;D834&#125;'</span>); <span class="comment">// ""\\uD834""</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>UTF-8 标准规定，<code>0xD800</code> 到 <code>0xDFFF</code> 之间的码点，不能单独使用，必须配对使用。</p>
</blockquote>
<p>&nbsp;</p>
<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<p>如果 <code>${}</code> 中的值不是字符串，将按照一般的规则转为字符串，比如，<code>${}</code> 中是一个对象，将默认调用对象的 <code>toString</code> 方法。</p>
<h3 id="标签模板"><a href="#标签模板" class="headerlink" title="标签模板"></a>标签模板</h3><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串，这被称为“标签模板”功能（tagged template）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="string">`123`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>标签模板其实不是模板，而是函数调用的一种特殊形式，“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p><strong>如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123;a + b&#125;</span> world <span class="subst">$&#123;a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个 <code>raw</code> 属性，其保存的是转义后的原字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// strings.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">  <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回 <code>undefined</code>，而不是报错（<strong>这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错</strong>。）。</p>
<p>&nbsp;</p>
<h2 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h2><h3 id="String-fromCodePoint"><a href="#String-fromCodePoint" class="headerlink" title="String.fromCodePoint()"></a>String.fromCodePoint()</h3><p>用于从 Unicode 码点返回对应字符，可以识别大于 <code>0xFFFF</code> 的字符，弥补了 ES5 的 <code>String.fromCharCode()</code> 方法的不足。</p>
<p>如果<code>String.fromCodePoint</code>方法有多个参数，则它们会被合并成一个字符串返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x🚀y'</span>;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="实例方法：codePointAt"><a href="#实例方法：codePointAt" class="headerlink" title="实例方法：codePointAt()"></a>实例方法：codePointAt()</h3><p><code>codePointAt()</code> 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 <code>charCodeAt()</code> 方法相同。</p>
<p><code>codePointAt()</code> 方法返回的是码点的十进制值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>); <span class="comment">// 𠮷 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>); <span class="comment">// 𠮷的后两个字节 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>); <span class="comment">// a 97</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法1 for...of 循环会正确识别 32 位的 UTF-16 字符</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法2 使用扩展运算符（...）进行展开运算</span></span><br><span class="line"><span class="keyword">let</span> arr = [...<span class="string">'𠮷a'</span>]; <span class="comment">// arr.length === 2</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">ch</span>) =&gt;</span> <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)));</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>

<p><code>codePointAt()</code> 方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<p><strong><code>fromCodePoint</code> 方法定义在 <code>String</code> 对象上，而<code>codePointAt</code> 方法定义在字符串的实例对象上。</strong></p>
<hr>
<h3 id="String-row"><a href="#String-row" class="headerlink" title="String.row()"></a>String.row()</h3><p>&nbsp;</p>
<h1 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h1><h2 id="Iterator-的概念"><a href="#Iterator-的概念" class="headerlink" title="Iterator 的概念"></a>Iterator 的概念</h2><p>Iterator 是一种接口，为各种不同的数据结构（<code>Array</code>，<code>Map</code>，<code>Set</code> 等）提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。</p>
<p>Iterator 的作用有三个：</p>
<ul>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，Iterator 接口主要供<code>for...of</code> 消费。</li>
</ul>
<p>Iterator 的遍历过程:</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上就是一个指针对象。</li>
<li>第一次调用指针对象的 <code>next</code> 方法，可以将指针指向数据结构的第一个成员。</li>
<li>第二次调用指针对象的 <code>next</code> 方法，指针就指向数据结构的第二个成员。</li>
<li>不断调用指针对象的 <code>next</code> 方法，直到它指向数据结构的结束位置。</li>
</ol>
<p>每一次调用 <code>next</code> 方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含 <code>value</code>和 <code>done</code> 两个属性的对象。其中，<code>value</code> 属性是当前成员的值，<code>done</code> 属性是一个布尔值，表示遍历是否结束。</p>
<p>&nbsp;</p>
<h2 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h2><p>当使用 <code>for...of</code> 循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的 <code>Symbol.iterator</code> 属性，或者说，一个数据结构只要具有 <code>Symbol.iterator</code> 属性，就可以认为是“可遍历的”（iterable）。</p>
<p><code>Symbol.iterator</code> 属性本身是一个函数，就是当前数据结构默认的遍历器生成函数，执行这个函数就会返回一个遍历器对象，该对象的根本特征就是具有 <code>next</code> 方法。每次调用 <code>next</code> 方法，都会返回一个代表当前成员的信息对象，具有 <code>value</code> 和 <code>done</code> 两个属性。</p>
<p>原生具备 Iterator 接口的数据结构:</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p><strong>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code> 循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在 <code>Symbol.iterator</code> 属性上面部署，这样才会被 <code>for...of</code> 循环遍历。</strong></p>
<p><strong>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。</strong></p>
<p>对于类似数组的对象（存在数值键名和 <code>length</code> 属性），部署 Iterator 接口，有一个简便方法，就是 <code>Symbol.iterator</code> 方法直接引用数组的 Iterator 接口。</p>
<p>&nbsp;</p>
<h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>对数组和 <code>Set</code> 结构进行解构赋值时，会默认调用 <code>Symbol.iterator</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set()</span><br><span class="line">  .add('a')</span><br><span class="line">  .add('b')</span><br><span class="line">  .add('c');</span><br><span class="line"></span><br><span class="line">let [x, y] = <span class="keyword">set</span>; // x='a'; y='b'</span><br><span class="line"></span><br><span class="line">let [first, ...rest] = <span class="keyword">set</span>; // first='a'; rest=['b', 'c'];</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'hello'</span>;</span><br><span class="line">[...str]; <span class="comment">//  ['h', 'e', 'l', 'l', 'o']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]; <span class="comment">// ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。也就是说，只要某个数据结构部署了 Iterator 接口，就可以对它使用扩展运算符，将其转为数组。</p>
</blockquote>
<hr>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p><code>yield*</code> 后面跟的是一个可遍历的结构，它会调用该结构的 Iterator 接口。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a>其他场合</h3><p>由于数组的遍历会调用 Iterator 接口，所以任何接受数组作为参数的场合，其实都调用了 Iterator 接口：</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如 <code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<p>&nbsp;</p>
<h2 id="Iterator-接口与-Generator-函数"><a href="#Iterator-接口与-Generator-函数" class="headerlink" title="Iterator 接口与 Generator 函数"></a>Iterator 接口与 Generator 函数</h2><p><code>Symbol.iterator</code> 方法的最简单实现，是使用 Generator 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myIterable = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator] () &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "hello"</span></span><br><span class="line"><span class="comment">// "world"</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="遍历器对象的-return-throw"><a href="#遍历器对象的-return-throw" class="headerlink" title="遍历器对象的 return(), throw()"></a>遍历器对象的 return(), throw()</h2><p>遍历器对象除了具有 <code>next</code> 方法，还可以具有 <code>return</code> 方法和 <code>throw</code> 方法。<code>next</code> 方法是必须部署的，<code>return</code> 方法和 <code>throw</code> 方法是否部署是可选的。</p>
<p><code>return</code> 方法的使用场合是如果 <code>for...of</code> 循环提前退出（通常是因为出错，或者有 <code>break</code> 语句），就会调用 <code>return</code> 方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署 <code>return</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        next() &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">          file.close();</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>throw</code> 方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</p>
</blockquote>
<h2 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性，就被视为具有 Iterator 接口，就可以用 <code>for...of</code> 循环遍历它的成员，也就是说，<code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>for...of</code> 循环调用 Iterator 接口，数组的 Iterator 接口只返回具有数字索引的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">arr.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// "0", "1", "2", "foo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">//  "3", "5", "7"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><p>遍历的顺序是按照各个成员被添加进数据结构的顺序。<code>Set</code> 结构遍历时，返回的是一个值，而 <code>Map</code> 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 <code>Map</code> 成员的键名和键值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ['a', 1]</span></span><br><span class="line"><span class="comment">// ['b', 2]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>有些数据结构是在现有数据结构的基础上，计算生成的：</p>
<ul>
<li><code>entries()</code> 返回一个遍历器对象，用来遍历 <code>[key, value]</code> 组成的数组。对于数组，<code>key</code> 就是索引值；对于 <code>Set</code>，<code>key</code> 与 <code>value</code> 相同；<code>Map</code> 结构的 Iterator 接口，默认就是调用 <code>entries</code> 方法。</li>
<li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的 <code>key</code>。</li>
<li><code>values()</code> 返回一个遍历器对象，用来遍历所有的 <code>value</code>。</li>
</ul>
<hr>
<h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用<code>Array.from</code> 方法将其转为数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h1 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>执行 Generator 函数会返回一个<strong>遍历器对象</strong>，也就是说，Generator 函数是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>Generator 函数是一个普通函数，但是有两个特征：</p>
<ul>
<li><code>function</code> 关键字与函数名之间有一个 <code>*</code>；</li>
<li>函数体内部使用 <code>yield</code> 表达式，定义不同的内部状态。</li>
</ul>
<p>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象——遍历器对象（Iterator Object）。必须调用遍历器对象的 <code>next</code> 方法，使得指针移向下一个状态，也就是说，每次调用 <code>next</code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code>yield</code> 表达式（或 <code>return</code> 语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code> 表达式是暂停执行的标记，而 <code>next</code> 方法可以恢复执行。</p>
<hr>
<h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield 表达式"></a>yield 表达式</h3><p>遍历器对象的 <code>next</code> 方法的运行逻辑如下：</p>
<ol>
<li>遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</li>
<li>下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式。</li>
<li>如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值。</li>
<li>如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code>。</li>
</ol>
<p><strong>需要注意的是，<code>yield</code> 表达式后面的表达式，只有当调用 <code>next</code> 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield 后面的表达式不会立即求值，只会在 next 方法将指针移到这一句时，才会求值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Generator 函数可以不用 <code>yield</code> 表达式，这时就变成了一个单纯的暂缓执行函数。</p>
<p><strong><code>yield</code> 表达式如果用在另一个表达式之中，必须放在圆括号里面。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>yield</code> 表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">'a'</span>, <span class="keyword">yield</span> <span class="string">'b'</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h3><p>由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的 <code>Symbol.iterator</code> 属性，从而使得该对象具有 Iterator 接口。</p>
<p>Generator 函数执行后，返回一个遍历器对象。该对象本身也具有 <code>Symbol.iterator</code> 属性，执行后返回自身。</p>
<p>&nbsp;</p>
<h2 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h2><p><code>yield</code> 表达式本身没有返回值，或者说总是返回 <code>undefined</code>。<code>next</code> 方法可以带一个参数，该参数就会被当作<strong>上一个</strong> <code>yield</code> 表达式的返回值。</p>
<blockquote>
<p>由于 <code>next</code> 方法的参数表示上一个 <code>yield</code> 表达式的返回值，所以在第一次使用 <code>next</code> 方法时，传递参数是无效的，V8 引擎将直接忽略第一次使用 <code>next</code> 方法时的参数，只有从第二次使用 <code>next</code> 方法开始，参数才是有效的。从语义上讲，第一个 <code>next</code> 方法用来启动遍历器对象，所以不用带有参数。</p>
</blockquote>
<p>&nbsp;</p>
<h2 id="for…of-循环-1"><a href="#for…of-循环-1" class="headerlink" title="for…of 循环"></a>for…of 循环</h2><p><code>for...of</code> 循环可以自动遍历 Generator 函数运行时生成的遍历器对象，且此时不再需要调用 <code>next</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<p><strong>一旦 <code>next</code> 方法的返回对象的 <code>done</code> 属性为 <code>true</code>，<code>for...of</code> 循环就会中止，且不包含该返回对象，所以上面代码的 <code>return</code> 语句返回的 4，不包括在 <code>for...of</code> 循环之中。</strong></p>
<p><strong>除了 <code>for...of</code> 循环以外，扩展运算符（<code>...</code>）、解构赋值和 <code>Array.from</code> 方法内部调用的，都是遍历器接口，这意味着，它们都可以将 Generator 函数返回的遍历器对象作为参数。</strong></p>
<p>&nbsp;</p>
<h2 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h2><p>Generator 函数返回的遍历器对象，都有一个 <code>throw</code> 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>

<p><code>throw</code> 方法可以接受一个参数，该参数会被 <code>catch</code> 语句接收，建议抛出 <code>Error</code> 对象的实例。</p>
<blockquote>
<p><code>throw</code> 命令抛出的错误只能被函数体外的 <code>catch</code> 语句捕获。</p>
</blockquote>
<p><strong>如果 Generator 函数内部没有部署 <code>try...catch</code> 代码块，那么 <code>throw</code> 方法抛出的错误，将被外部 <code>try...catch</code> 代码块捕获。而如果 Generator 函数内部和外部都没有部署 <code>try...catch</code> 代码块，那么程序将报错，直接中断执行。</strong></p>
<p><strong><code>throw</code> 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 <code>next</code> 方法（即启动状态的遍历器对象才可以捕获错误）。</strong></p>
<p><code>throw</code> 方法被捕获以后，会附带执行下一条 <code>yield</code> 表达式，也就是说，会附带执行一次 <code>next</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line">g.next(); <span class="comment">// a</span></span><br><span class="line">g.throw(); <span class="comment">// b</span></span><br><span class="line">g.next(); <span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只要 Generator 函数内部部署了 <code>try...catch</code> 代码块，那么遍历器的 <code>throw</code> 方法抛出的错误不影响下一次遍历。</p>
</blockquote>
<p><strong>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 <code>next</code> 方法，将返回一个 <code>value</code> 属性等于 <code>undefined</code>、<code>done</code> 属性等于 <code>true</code> 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</strong></p>
<p>&nbsp;</p>
<h2 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h2><p>Generator 函数返回的遍历器对象的 <code>return</code> 方法可以返回给定的值，并且终结遍历 Generator 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">'foo'</span>); <span class="comment">// &#123; value: "foo", done: true &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>return</code> 方法调用时，不提供参数，则返回值的 <code>value</code> 属性为 <code>undefined</code>。</p>
<p>如果 Generator 函数内部有 <code>try...finally</code> 代码块，且正在执行 <code>try</code> 代码块，那么 <code>return</code> 方法会导致立刻进入 <code>finally</code> 代码块，执行完以后，整个函数才会结束。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = numbers();</span><br><span class="line">g.next(); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next(); <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="yield-表达式-1"><a href="#yield-表达式-1" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p><code>yield*</code> 表达式用于在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从语法角度看，如果 <code>yield</code> 表达式后面跟的是一个遍历器对象，需要在 <code>yield</code> 表达式后面加上 <code>*</code>，表明它返回的是一个遍历器对象。</p>
<p><code>yield*</code> 后面的 Generator 函数（<strong>没有 <code>return</code> 语句时</strong>），等同于在 Generator 函数内部，部署一个 <code>for...of</code> 循环。在有 <code>return</code> 语句时，则需要用 <code>let value = yield* iterator</code> 的形式获取 <code>return</code> 语句的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span>* foo();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'v: '</span> + v);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// "v: foo"</span></span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next();</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>yield*</code> 后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。实际上，任何数据结构只要有 Iterator 接口，就可以被 <code>yield*</code> 遍历。</p>
<p><code>yield*</code> 命令可以很方便地取出嵌套数组的所有成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [<span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>]];</span><br><span class="line"></span><br><span class="line">[...iterTree(tree)]; <span class="comment">// ["a", "b", "c", "d", "e"]</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="作为对象属性的-Generator-函数"><a href="#作为对象属性的-Generator-函数" class="headerlink" title="作为对象属性的 Generator 函数"></a>作为对象属性的 Generator 函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  *myGeneratorMethod() &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="Generator-函数的-this"><a href="#Generator-函数的-this" class="headerlink" title="Generator 函数的 this"></a>Generator 函数的 this</h2><p><strong>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的 <code>prototype</code> 对象上的方法。</strong></p>
<p>如果把 Generator 函数当作普通的构造函数，并不会生效，因为 Generator 函数返回的总是遍历器对象，而不是 <code>this</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g();</span><br><span class="line">obj.next();</span><br><span class="line">obj.a; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>Generator 函数也不能跟 <code>new</code> 命令一起用。</p>
<p>让 Generator 函数返回一个正常的对象实例，既可以用 <code>next</code> 方法，又可以获得正常的 <code>this</code> 的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> (<span class="keyword">this</span>.b = <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">yield</span> (<span class="keyword">this</span>.c = <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a; <span class="comment">// 1</span></span><br><span class="line">f.b; <span class="comment">// 2</span></span><br><span class="line">f.c; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="Generator-与上下文"><a href="#Generator-与上下文" class="headerlink" title="Generator 与上下文"></a>Generator 与上下文</h2><p>JavaScript 代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。</p>
<p>这个堆栈是“后进先出”的数据结构，最后产生的上下文环境首先执行完成，退出堆栈，然后再执行完成它下层的上下文，直至所有代码执行完成，堆栈清空。</p>
<p>Generator 函数不是这样，它执行产生的上下文环境，一旦遇到 <code>yield</code> 命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行 <code>next</code> 命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。</p>
<h1 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h1><p><code>ArrayBuffer</code> 对象、<code>TypedArray</code> 视图和 <code>DataView</code> 视图是 JavaScript 操作二进制数据的一个接口。</p>
<ul>
<li><code>ArrayBuffer</code> 对象：代表内存之中的一段二进制数据，可以通过“视图”进行操作，而“视图”则部署了数组接口，可以用数组的方法操作内存。</li>
<li><code>TypedArray</code> 视图：共包括 9 种类型的视图。</li>
<li><code>DataView</code> 视图：可以自定义复合格式的视图，还可以自定义字节序。</li>
</ul>
<p><code>TypedArray</code> 视图支持的数据类型一共有 9 种（<code>DataView</code> 视图支持除 <code>Uint8ClampedArray</code> 以外的其他 8 种）。</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="center">字节长度</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Int8Array</td>
<td align="center">1</td>
<td align="left">8 位带符号整数</td>
</tr>
<tr>
<td align="left">Uint8Array</td>
<td align="center">1</td>
<td align="left">8 位不带符号整数</td>
</tr>
<tr>
<td align="left">Uint8ClampedArray</td>
<td align="center">1</td>
<td align="left">8 位不带符号整数（自动过滤溢出）</td>
</tr>
<tr>
<td align="left">Int16Array</td>
<td align="center">2</td>
<td align="left">16 位带符号整数</td>
</tr>
<tr>
<td align="left">Uint16Array</td>
<td align="center">2</td>
<td align="left">16 位不带符号整数</td>
</tr>
<tr>
<td align="left">Int32Array</td>
<td align="center">4</td>
<td align="left">32 位带符号整数</td>
</tr>
<tr>
<td align="left">Uint32Array</td>
<td align="center">4</td>
<td align="left">32 位不带符号整数</td>
</tr>
<tr>
<td align="left">Float32Array</td>
<td align="center">4</td>
<td align="left">32 位浮点数</td>
</tr>
<tr>
<td align="left">Float64Array</td>
<td align="center">8</td>
<td align="left">64 位浮点数</td>
</tr>
</tbody></table>
<blockquote>
<p>二进制数组并不是真正的数组，而是类似数组的对象。</p>
</blockquote>
<h2 id="ArrayBuffer-对象"><a href="#ArrayBuffer-对象" class="headerlink" title="ArrayBuffer 对象"></a>ArrayBuffer 对象</h2><p><code>ArrayBuffer</code> 对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（<code>TypedArray</code> 视图和 <code>DataView</code> 视图）以指定格式来读写二进制数据。</p>
<p>调用 <code>ArrayBuffer</code> 构造函数会分配一段可以存放数据的连续内存区域，<code>ArrayBuffer</code> 构造函数的参数是所需要的内存大小（单位字节）。</p>
<h3 id="ArrayBuffer-prototype-byteLength"><a href="#ArrayBuffer-prototype-byteLength" class="headerlink" title="ArrayBuffer.prototype.byteLength"></a>ArrayBuffer.prototype.byteLength</h3><p><code>ArrayBuffer</code> 实例的 <code>byteLength</code> 属性返回所分配的内存区域的字节长度。</p>
<p><strong>如果要分配的内存区域很大，有可能分配失败（因为没有那么多的连续空余内存）</strong>。</p>
<hr>
<h3 id="ArrayBuffer-prototype-slice"><a href="#ArrayBuffer-prototype-slice" class="headerlink" title="ArrayBuffer.prototype.slice()"></a>ArrayBuffer.prototype.slice()</h3><p><code>slice</code> 方法允许将内存区域的一部分，拷贝生成一个新的 <code>ArrayBuffer</code> 对象。</p>
<p><code>slice</code> 方法包含两步，第一步是先分配一段新内存，第二步是将原来那个 <code>ArrayBuffer</code> 对象拷贝过去。</p>
<p><strong>除了 <code>slice</code> 方法，<code>ArrayBuffer</code> 对象不提供任何直接读写内存的方法，只允许在其上方建立视图，然后通过视图读写</strong>。</p>
<hr>
<h3 id="ArrayBuffer-isView"><a href="#ArrayBuffer-isView" class="headerlink" title="ArrayBuffer.isView()"></a>ArrayBuffer.isView()</h3><p>静态方法 <code>isView</code> 返回一个布尔值，表示参数是否为 <code>ArrayBuffer</code> 的视图实例。该方法大致相当于判断参数是否为 <code>TypedArray</code> 实例或 <code>DataView</code> 实例。</p>
<p>&nbsp;</p>
<h2 id="TypedArray-视图"><a href="#TypedArray-视图" class="headerlink" title="TypedArray 视图"></a>TypedArray 视图</h2><p><code>TypedArray</code> 很像普通数组，都有 <code>length</code> 属性，都能用方括号运算符（<code>[]</code>）获取单个元素，所有数组的方法，在它们上面都能使用。</p>
<p>普通数组与 <code>TypedArray</code> 数组的差异主要在以下方面：</p>
<ul>
<li><code>TypedArray</code> 数组的所有成员都是同一种类型。</li>
<li><code>TypedArray</code> 数组的成员是连续的，不会有空位。</li>
<li><code>TypedArray</code> 数组成员的默认值为 <code>0</code>。</li>
<li><code>TypedArray</code> 数组只是一层视图，本身不储存数据，它的数据都储存在底层的 <code>ArrayBuffer</code> 对象之中，要获取底层对象必须使用 <code>buffer</code> 属性。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>TypedArray</code> 构造函数有多种用法。</p>
<h4 id="TypedArray-buffer-byteOffset-0-length"><a href="#TypedArray-buffer-byteOffset-0-length" class="headerlink" title="TypedArray(buffer, byteOffset=0, length?)"></a>TypedArray(buffer, byteOffset=0, length?)</h4><p>视图的构造函数可以接受三个参数：</p>
<ul>
<li>buffer（必需）：视图对应的底层 <code>ArrayBuffer</code> 对象。</li>
<li>byteOffset（可选）：视图开始的字节序号，默认从 0 开始。</li>
<li>length（可选）：视图包含的数据个数，默认直到本段内存区域结束。</li>
</ul>
<blockquote>
<p>注意，<code>byteOffset</code> 必须与所要建立的数据类型一致。如果想从任意字节开始解读 <code>ArrayBuffer</code> 对象，必须使用 <code>DataView</code> 视图。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> i16 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(buffer, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Uncaught RangeError: start offset of Int16Array should be a multiple of 2</span></span><br></pre></td></tr></table></figure>

<h4 id="TypedArray-length"><a href="#TypedArray-length" class="headerlink" title="TypedArray(length)"></a>TypedArray(length)</h4><p>视图还可以不通过 <code>ArrayBuffer</code> 对象，直接分配内存而生成，这时，视图构造函数的参数就是 <code>TypedArray</code> 数组成员的个数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f64a = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 生成一个 8 个成员的 Float64Array 数组（共 64 字节）</span></span><br></pre></td></tr></table></figure>

<h4 id="TypedArray-typedArray"><a href="#TypedArray-typedArray" class="headerlink" title="TypedArray(typedArray)"></a>TypedArray(typedArray)</h4><p><code>TypedArray</code> 数组的构造函数，可以接受另一个 <code>TypedArray</code> 实例作为参数，<strong>此时生成的新数组只是复制了参数数组的值，对应的底层内存是不一样的，新数组会开辟一段新的内存储存数据，不会在原数组的内存之上建立视图</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typedArray = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>如果想基于同一段内存构造不同的视图，可以采用下面的写法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="keyword">new</span> <span class="built_in">Int8Array</span>([<span class="number">1</span>, <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> y = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(x.buffer);</span><br></pre></td></tr></table></figure>

<h4 id="TypedArray-arrayLikeObject"><a href="#TypedArray-arrayLikeObject" class="headerlink" title="TypedArray(arrayLikeObject)"></a>TypedArray(arrayLikeObject)</h4><p>构造函数的参数也可以是一个普通数组，然后直接生成 <code>TypedArray</code> 实例，这时 <code>TypedArray</code> 视图会重新开辟内存，不会在原数组的内存上建立视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typedArray = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<p><code>TypedArray</code> 数组也可以转换回普通数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> normalArray = [...typedArray];</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> normalArray = <span class="built_in">Array</span>.from(typedArray);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> normalArray = <span class="built_in">Array</span>.prototype.slice.call(typedArray);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><p>普通数组的操作方法和属性，对 <code>TypedArray</code> 数组完全适用。</p>
<blockquote>
<p>注意，<code>TypedArray</code> 数组没有 <code>concat</code> 方法。</p>
</blockquote>
<p>另外，<code>TypedArray</code> 数组与普通数组一样，部署了 Iterator 接口，所以可以被遍历。</p>
<hr>
<h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>字节序指的是数值在内存中的表示方式。</p>
<p>x86 体系的计算机都采用小端字节序（little endian），相对重要的字节排在后面的内存地址，相对不重要字节排在前面的内存地址，大端字节序则完全相反，将最重要的字节排在前面。</p>
<p>目前，所有个人电脑几乎都是小端字节序，所以 <code>TypedArray</code> 数组内部也采用小端字节序读写数据，或者更准确的说，按照本机操作系统设定的字节序读写数据。</p>
<p>如果一段数据是大端字节序，<code>TypedArray</code> 数组将无法正确解析，因为它只能处理小端字节序。为了解决这个问题，JavaScript 引入了 <code>DataView</code> 对象，它可以设定字节序。</p>
<hr>
<h3 id="BYTES-PER-ELEMENT-属性"><a href="#BYTES-PER-ELEMENT-属性" class="headerlink" title="BYTES_PER_ELEMENT 属性"></a>BYTES_PER_ELEMENT 属性</h3><p>每一种视图的构造函数都有一个 <code>BYTES_PER_ELEMENT</code> 属性，表示这种数据类型占据的字节数。</p>
<p>这个属性在 <code>TypedArray</code> 实例上也能获取。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Int8Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Uint8Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Uint8ClampedArray</span>.BYTES_PER_ELEMENT; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Int16Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Uint16Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Int32Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Uint32Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Float32Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Float64Array</span>.BYTES_PER_ELEMENT; <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ArrayBuffer-与字符串的互相转换"><a href="#ArrayBuffer-与字符串的互相转换" class="headerlink" title="ArrayBuffer 与字符串的互相转换"></a>ArrayBuffer 与字符串的互相转换</h3><p>使用原生 <code>TextEncoder</code> 和 <code>TextDecoder</code> 方法进行 <code>ArrayBuffer</code> 和字符串的相互转换。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert ArrayBuffer/TypedArray to String via TextDecoder</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see https://developer.mozilla.org/en-US/docs/Web/API/TextDecoder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ab2str</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  input:</span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">ArrayBuffer</span></span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Uint8Array</span></span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Int8Array</span></span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Uint16Array</span></span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Int16Array</span></span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Uint32Array</span></span></span></span><br><span class="line"><span class="function"><span class="params">    | <span class="built_in">Int32Array</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  outputEncoding: <span class="built_in">string</span> = 'utf8'</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> decoder = <span class="keyword">new</span> TextDecoder(outputEncoding);</span><br><span class="line">  <span class="keyword">return</span> decoder.decode(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Convert String to ArrayBuffer via TextEncoder</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @see https://developer.mozilla.org/zh-CN/docs/Web/API/TextEncoder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2ab</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">ArrayBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> view = str2Uint8Array(input);</span><br><span class="line">  <span class="keyword">return</span> view.buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Convert String to Uint8Array */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">str2Uint8Array</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">Uint8Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line">  <span class="keyword">const</span> view = encoder.encode(input);</span><br><span class="line">  <span class="keyword">return</span> view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h3><p><code>TypedArray</code> 数组的溢出处理规则简单来说就是抛弃溢出的位，然后按照视图类型进行解释。</p>
<p><strong>数字在计算机内部采用“补码”表示，正数的“原码”与“补码”相同。</strong>。</p>
<blockquote>
<ul>
<li>原码求补码：正数不变，负数将其原码除符号位外的所有位取反后加 1。</li>
<li>补码求原码：如果补码的符号位为 0，表示是一个正数，其原码就是补码，否则将其除符号位外的所有位取反后加 1。</li>
</ul>
</blockquote>
<p>简单转换规则可以这样表示：</p>
<ul>
<li>正向溢出（overflow）：当输入值大于当前数据类型的最大值，结果等于当前数据类型的最小值加上余值，再减去 1。</li>
<li>负向溢出（underflow）：当输入值小于当前数据类型的最小值，结果等于当前数据类型的最大值减去余值的绝对值，再加上 1。</li>
</ul>
<p><strong><code>Uint8ClampedArray</code> 视图的溢出规则与其它视图不同。它规定凡是发生正向溢出，该值一律等于当前数据类型的最大值；如果发生负向溢出，该值一律等于当前数据类型的最小值</strong>。</p>
<hr>
<h3 id="TypedArray-prototype-buffer"><a href="#TypedArray-prototype-buffer" class="headerlink" title="TypedArray.prototype.buffer"></a>TypedArray.prototype.buffer</h3><p><code>TypedArray</code> 实例的 <code>buffer</code> 属性返回整段内存区域对应的 <code>ArrayBuffer</code> 对象，只读属性。</p>
<hr>
<h3 id="TypedArray-prototype-byteLength"><a href="#TypedArray-prototype-byteLength" class="headerlink" title="TypedArray.prototype.byteLength"></a>TypedArray.prototype.byteLength</h3><p><code>byteLength</code> 属性返回 <code>TypedArray</code> 数组占据的内存长度，单位为字节，只读属性。</p>
<hr>
<h3 id="TypedArray-prototype-byteOffset"><a href="#TypedArray-prototype-byteOffset" class="headerlink" title="TypedArray.prototype.byteOffset"></a>TypedArray.prototype.byteOffset</h3><p><code>byteOffset</code> 属性返回 <code>TypedArray</code> 数组从底层 <code>ArrayBuffer</code> 对象的哪个字节开始，只读属性。</p>
<hr>
<h3 id="TypedArray-prototype-length"><a href="#TypedArray-prototype-length" class="headerlink" title="TypedArray.prototype.length"></a>TypedArray.prototype.length</h3><p><code>length</code> 属性表示 <code>TypedArray</code> 数组含有多少个成员。</p>
<blockquote>
<p>注意区分 <code>length</code> 属性和 <code>byteLength</code> 属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">a.length; <span class="comment">// 8</span></span><br><span class="line">a.byteLength; <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="TypedArray-prototype-set"><a href="#TypedArray-prototype-set" class="headerlink" title="TypedArray.prototype.set()"></a>TypedArray.prototype.set()</h3><p><code>set</code> 方法用于复制数组（普通数组或 <code>TypedArray</code> 数组），也就是将一段内容完全复制到另一段内存。</p>
<p><code>set</code> 方法还可以接受第二个参数，表示从调用方的哪一个成员开始复制。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">b.set(a, <span class="number">2</span>); <span class="comment">// 从 b[2] 开始复制 a</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="TypedArray-prototype-subarray"><a href="#TypedArray-prototype-subarray" class="headerlink" title="TypedArray.prototype.subarray()"></a>TypedArray.prototype.subarray()</h3><p><code>subarray</code> 方法是对于 <code>TypedArray</code> 数组的一部分，再建立一个新的视图。</p>
<p><code>subarray</code> 方法的第一个参数是起始的成员序号，第二个参数是结束的成员序号（不含该成员），如果省略则包含剩余的全部成员。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.subarray(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 只包含 a[2] 一个成员</span></span><br><span class="line"></span><br><span class="line">a.byteLength; <span class="comment">// 16</span></span><br><span class="line">b.byteLength; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="TypedArray-prototype-slice"><a href="#TypedArray-prototype-slice" class="headerlink" title="TypedArray.prototype.slice()"></a>TypedArray.prototype.slice()</h3><p><code>TypeArray</code> 实例的 <code>slice</code> 方法，可以返回一个指定位置的新的<code>TypedArray</code> 实例。</p>
<p><code>slice</code> 方法的参数同普通数组的 <code>slice</code> 方法。</p>
<hr>
<h3 id="TypedArray-of"><a href="#TypedArray-of" class="headerlink" title="TypedArray.of()"></a>TypedArray.of()</h3><p><code>TypedArray</code> 数组的所有构造函数都有一个静态方法 <code>of</code>，用于将参数转为一个 <code>TypedArray</code> 实例。</p>
<p>下面三种方法都会生成一个成员相同的 <code>TypedArray</code> 数组。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">let</span> tarr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">let</span> tarr = <span class="built_in">Uint8Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="keyword">let</span> tarr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">3</span>);</span><br><span class="line">tarr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">tarr[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">tarr[<span class="number">2</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="TypedArray-from"><a href="#TypedArray-from" class="headerlink" title="TypedArray.from()"></a>TypedArray.from()</h3><p>静态方法 <code>from</code> 接受一个可遍历的数据结构（比如数组）作为参数，返回一个基于这个结构的 <code>TypedArray</code> 实例。</p>
<p>该方法还可以将一种 <code>TypedArray</code> 实例，转为另一种。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ui16 = <span class="built_in">Uint16Array</span>.from(<span class="built_in">Uint8Array</span>.of(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">ui16 <span class="keyword">instanceof</span> <span class="built_in">Uint16Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>from</code> 方法还可以接受一个函数作为第二个参数，用来对每个元素进行遍历，功能类似 <code>map</code> 方法。</p>
<p><strong><code>from</code> 会将第一个参数指定的 <code>TypedArray</code> 数组，拷贝到另一段内存之中，处理之后再将结果转成指定的数组格式</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Int16Array</span>.from(<span class="built_in">Int8Array</span>.of(<span class="number">127</span>, <span class="number">126</span>, <span class="number">125</span>), (x) =&gt; <span class="number">2</span> * x);</span><br><span class="line"><span class="comment">// Int16Array [ 254, 252, 250 ] 没有溢出</span></span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="复合视图"><a href="#复合视图" class="headerlink" title="复合视图"></a>复合视图</h2><p>由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节 0 到字节 3：1 个 32 位无符号整数</span></span><br><span class="line"><span class="keyword">const</span> idView = <span class="keyword">new</span> <span class="built_in">Uint32Array</span>(buffer, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 字节 4 到字节 19：16 个 8 位整数</span></span><br><span class="line"><span class="keyword">const</span> usernameView = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer, <span class="number">4</span>, <span class="number">16</span>);</span><br><span class="line"><span class="comment">// 字节 20 到字节 23：1 个 32 位浮点数</span></span><br><span class="line"><span class="keyword">const</span> amountDueView = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(buffer, <span class="number">20</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="DataView-视图"><a href="#DataView-视图" class="headerlink" title="DataView 视图"></a>DataView 视图</h2><p>如果一段数据包括多种类型，这时除了建立 <code>ArrayBuffer</code> 对象的复合视图以外，还可以通过 <code>DataView</code> 视图进行操作，<code>DataView</code> 视图提供更多操作选项，而且支持设定字节序。</p>
<blockquote>
<p>本来，在设计目的上，<code>ArrayBuffer</code> 对象的各种 <code>TypedArray</code> 视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而 <code>DataView</code> 视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p>
</blockquote>
<p><code>DataView</code> 构造函数接受一个 <code>ArrayBuffer</code> 对象作为参数，生成视图。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">DataView</span>(<span class="built_in">ArrayBuffer</span> buffer [, 字节起始位置 [, 长度]]);</span><br></pre></td></tr></table></figure>

<h1 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h1><p>ES5 只有两种声明变量的方法：<code>var</code> 命令和 <code>function</code> 命令。ES6 添加了 <code>let</code> 命令，<code>const</code> 命令，<code>import</code> 命令和 <code>class</code> 命令，所以截至目前，ES6 一共有 6 种声明变量的方法。</p>
<p><code>var</code> 命令和 <code>function</code> 命令声明的全局变量，是顶层对象的属性，而 <code>let</code> 命令，<code>const</code> 命令，<code>class</code> 命令声明的全局变量，不属于顶层对象的属性。</p>
<blockquote>
<ul>
<li>浏览器里面，顶层对象是 <code>window</code>，但 Node 和 Web Worker 没有 <code>window</code>。</li>
</ul>
</blockquote>
<ul>
<li>浏览器和 Web Worker 里面，<code>self</code> 也指向顶层对象，但是 Node 没有 <code>self</code>。</li>
<li>Node 里面，顶层对象是 <code>global</code>，但其他环境都不支持。</li>
</ul>
<blockquote>
<p>现在有一个提案，在语言标准的层面，引入 <code>globalThis</code> 作为顶层对象。也就是说，任何环境下，<code>globalThis</code> 都是存在的，都可以从它拿到顶层对象，指向全局环境下的 <code>this</code>。</p>
</blockquote>

    </article>
    <!-- license  -->
    <!-- 
        <div class="license-wrapper">
            <p>原文作者：<a href="http://hitsuki9.github.io">Histuki9</a>
            <p>原文链接：<a href="http://hitsuki9.github.io/ecmascript-2015/">http://hitsuki9.github.io/ecmascript-2015/</a>
            <p>发表日期：<a href="http://hitsuki9.github.io/ecmascript-2015/">June 27th 2020, 12:00:00 am</a>
            <p>更新日期：<a href="http://hitsuki9.github.io/ecmascript-2015/">June 27th 2020, 5:53:36 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
     -->
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/design-patterns/" title= "设计模式">
                    <div class="prevTitle">设计模式</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="//github.com/hitsuki9" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            
                <a href="//juejin.im/user/5be2f141518825170108cd61" class="iconfont-archer juejin" target="_blank" title=juejin></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#let-和-const-命令"><span class="toc-number">1.</span> <span class="toc-text">let 和 const 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#let-命令"><span class="toc-number">1.1.</span> <span class="toc-text">let 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不存在变量提升"><span class="toc-number">1.1.1.</span> <span class="toc-text">不存在变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#暂时性死区"><span class="toc-number">1.1.2.</span> <span class="toc-text">暂时性死区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不允许重复声明"><span class="toc-number">1.1.3.</span> <span class="toc-text">不允许重复声明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#块级作用域"><span class="toc-number">1.2.</span> <span class="toc-text">块级作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-命令"><span class="toc-number">1.3.</span> <span class="toc-text">const 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本质"><span class="toc-number">1.3.1.</span> <span class="toc-text">本质</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#变量的解构赋值"><span class="toc-number">2.</span> <span class="toc-text">变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组的解构赋值"><span class="toc-number">2.1.</span> <span class="toc-text">数组的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认值"><span class="toc-number">2.1.1.</span> <span class="toc-text">默认值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的结构赋值"><span class="toc-number">2.2.</span> <span class="toc-text">对象的结构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认值-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注意点"><span class="toc-number">2.2.2.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的结构赋值"><span class="toc-number">2.3.</span> <span class="toc-text">字符串的结构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值和布尔值的解构赋值"><span class="toc-number">2.4.</span> <span class="toc-text">数值和布尔值的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数参数的解构赋值"><span class="toc-number">2.5.</span> <span class="toc-text">函数参数的解构赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#圆括号问题"><span class="toc-number">2.6.</span> <span class="toc-text">圆括号问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用途"><span class="toc-number">2.7.</span> <span class="toc-text">用途</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串的扩展"><span class="toc-number">3.</span> <span class="toc-text">字符串的扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符的-Unicode-表示法"><span class="toc-number">3.1.</span> <span class="toc-text">字符的 Unicode 表示法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的遍历器接口"><span class="toc-number">3.2.</span> <span class="toc-text">字符串的遍历器接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON-stringify-的改造"><span class="toc-number">3.3.</span> <span class="toc-text">JSON.stringify()的改造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板字符串"><span class="toc-number">3.4.</span> <span class="toc-text">模板字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#标签模板"><span class="toc-number">3.4.1.</span> <span class="toc-text">标签模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串的新增方法"><span class="toc-number">3.5.</span> <span class="toc-text">字符串的新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-fromCodePoint"><span class="toc-number">3.5.1.</span> <span class="toc-text">String.fromCodePoint()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例方法：codePointAt"><span class="toc-number">3.5.2.</span> <span class="toc-text">实例方法：codePointAt()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-row"><span class="toc-number">3.5.3.</span> <span class="toc-text">String.row()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Iterator"><span class="toc-number">4.</span> <span class="toc-text">Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-的概念"><span class="toc-number">4.1.</span> <span class="toc-text">Iterator 的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#默认-Iterator-接口"><span class="toc-number">4.2.</span> <span class="toc-text">默认 Iterator 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调用-Iterator-接口的场合"><span class="toc-number">4.3.</span> <span class="toc-text">调用 Iterator 接口的场合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解构赋值"><span class="toc-number">4.3.1.</span> <span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扩展运算符"><span class="toc-number">4.3.2.</span> <span class="toc-text">扩展运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield"><span class="toc-number">4.3.3.</span> <span class="toc-text">yield*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他场合"><span class="toc-number">4.3.4.</span> <span class="toc-text">其他场合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator-接口与-Generator-函数"><span class="toc-number">4.4.</span> <span class="toc-text">Iterator 接口与 Generator 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#遍历器对象的-return-throw"><span class="toc-number">4.5.</span> <span class="toc-text">遍历器对象的 return(), throw()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for…of-循环"><span class="toc-number">4.6.</span> <span class="toc-text">for…of 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">4.6.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-和-Map-结构"><span class="toc-number">4.6.2.</span> <span class="toc-text">Set 和 Map 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#计算生成的数据结构"><span class="toc-number">4.6.3.</span> <span class="toc-text">计算生成的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类似数组的对象"><span class="toc-number">4.6.4.</span> <span class="toc-text">类似数组的对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Generator-函数"><span class="toc-number">5.</span> <span class="toc-text">Generator 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">5.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield-表达式"><span class="toc-number">5.1.2.</span> <span class="toc-text">yield 表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与-Iterator-接口的关系"><span class="toc-number">5.1.3.</span> <span class="toc-text">与 Iterator 接口的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#next-方法的参数"><span class="toc-number">5.2.</span> <span class="toc-text">next 方法的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for…of-循环-1"><span class="toc-number">5.3.</span> <span class="toc-text">for…of 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-prototype-throw"><span class="toc-number">5.4.</span> <span class="toc-text">Generator.prototype.throw()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-prototype-return"><span class="toc-number">5.5.</span> <span class="toc-text">Generator.prototype.return()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yield-表达式-1"><span class="toc-number">5.6.</span> <span class="toc-text">yield* 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作为对象属性的-Generator-函数"><span class="toc-number">5.7.</span> <span class="toc-text">作为对象属性的 Generator 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-函数的-this"><span class="toc-number">5.8.</span> <span class="toc-text">Generator 函数的 this</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator-与上下文"><span class="toc-number">5.9.</span> <span class="toc-text">Generator 与上下文</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayBuffer"><span class="toc-number">6.</span> <span class="toc-text">ArrayBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBuffer-对象"><span class="toc-number">6.1.</span> <span class="toc-text">ArrayBuffer 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBuffer-prototype-byteLength"><span class="toc-number">6.1.1.</span> <span class="toc-text">ArrayBuffer.prototype.byteLength</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBuffer-prototype-slice"><span class="toc-number">6.1.2.</span> <span class="toc-text">ArrayBuffer.prototype.slice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBuffer-isView"><span class="toc-number">6.1.3.</span> <span class="toc-text">ArrayBuffer.isView()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypedArray-视图"><span class="toc-number">6.2.</span> <span class="toc-text">TypedArray 视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">6.2.1.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TypedArray-buffer-byteOffset-0-length"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">TypedArray(buffer, byteOffset&#x3D;0, length?)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypedArray-length"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">TypedArray(length)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypedArray-typedArray"><span class="toc-number">6.2.1.3.</span> <span class="toc-text">TypedArray(typedArray)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TypedArray-arrayLikeObject"><span class="toc-number">6.2.1.4.</span> <span class="toc-text">TypedArray(arrayLikeObject)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组方法"><span class="toc-number">6.2.2.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字节序"><span class="toc-number">6.2.3.</span> <span class="toc-text">字节序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BYTES-PER-ELEMENT-属性"><span class="toc-number">6.2.4.</span> <span class="toc-text">BYTES_PER_ELEMENT 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBuffer-与字符串的互相转换"><span class="toc-number">6.2.5.</span> <span class="toc-text">ArrayBuffer 与字符串的互相转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#溢出"><span class="toc-number">6.2.6.</span> <span class="toc-text">溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-prototype-buffer"><span class="toc-number">6.2.7.</span> <span class="toc-text">TypedArray.prototype.buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-prototype-byteLength"><span class="toc-number">6.2.8.</span> <span class="toc-text">TypedArray.prototype.byteLength</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-prototype-byteOffset"><span class="toc-number">6.2.9.</span> <span class="toc-text">TypedArray.prototype.byteOffset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-prototype-length"><span class="toc-number">6.2.10.</span> <span class="toc-text">TypedArray.prototype.length</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-prototype-set"><span class="toc-number">6.2.11.</span> <span class="toc-text">TypedArray.prototype.set()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-prototype-subarray"><span class="toc-number">6.2.12.</span> <span class="toc-text">TypedArray.prototype.subarray()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-prototype-slice"><span class="toc-number">6.2.13.</span> <span class="toc-text">TypedArray.prototype.slice()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-of"><span class="toc-number">6.2.14.</span> <span class="toc-text">TypedArray.of()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TypedArray-from"><span class="toc-number">6.2.15.</span> <span class="toc-text">TypedArray.from()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复合视图"><span class="toc-number">6.3.</span> <span class="toc-text">复合视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataView-视图"><span class="toc-number">6.4.</span> <span class="toc-text">DataView 视图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6-声明变量的六种方法"><span class="toc-number">7.</span> <span class="toc-text">ES6 声明变量的六种方法</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 8
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/27</span><a class="archive-post-title" href= "/ecmascript-2015/" >《ECMAScript 6 入门》读书笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/04</span><a class="archive-post-title" href= "/design-patterns/" >设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/15</span><a class="archive-post-title" href= "/css/" >CSS 知识点整理</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/26</span><a class="archive-post-title" href= "/react/" >React 知识点整理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/01</span><a class="archive-post-title" href= "/vue/" >Vue 知识点整理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/js-regexp/" >JS 正则表达式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href= "/webpack4/" >webpack4 配置详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span><a class="archive-post-title" href= "/git/" >Git 实用指南</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="前端"><span class="iconfont-archer">&#xe606;</span>前端</span>
    
        <span class="sidebar-tag-name" data-tags="git"><span class="iconfont-archer">&#xe606;</span>git</span>
    
        <span class="sidebar-tag-name" data-tags="正则"><span class="iconfont-archer">&#xe606;</span>正则</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="创作集"><span class="iconfont-archer">&#xe60a;</span>创作集</span>
    
        <span class="sidebar-category-name" data-categories="笔记"><span class="iconfont-archer">&#xe60a;</span>笔记</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Histuki9"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


